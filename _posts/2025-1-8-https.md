---
layout: post
title: "What I learned upgrading my Homelab servers to HTTPS"
tags: Blog, homelab security
---

# Introduction

I use my home network as a playground for learning new technologies and finding unique solutions to minor inconveniences in my life. For example, I couldn't find a thermostat on the market that can control an evaporative cooler and furnace. I was frustrated that each needed its own thermostat, so I designed and built a thermostat myself that could do both. This thermostat is a Raspberry Pi computer that hosts an SSH server, webserver, and Python Fast API in order to work properly. Currently, it's incredibly insecure.

As it stands right now, I can only check on my thermostat and control it when I am physically in my house. I would love to be able to access it from anywhere in the world, but doing so allows anyone pentest it from anywhere in the world. I need to feel a lot more comfortable with the security of my network and these servers before I would feel comfortable doing that.

So in this adventure, I have two goals. First, I would like to actually improve the security of my network and the servers/devices running on it. Second, I would like to generally improve my knowledge of cyber security concepts. So here's a knowledge dump of everything I've learned so far.

# How HTTPS works

A glaringly obvious and seemingly easy to solve issue I have is that my servers communicate via HTTP. This means the messages are sent unencrypted in plaintext. Some of my servers are password protected, and unless I upgrade them to HTTPS, the login information can be seen by anyone who happens to be listening.

HTTPS aims to do two things. The one I'm most interested in is that it encrypts the communication between the client and server, but its second aim is to ensure the server is who it say it is.

## Message flow

I love message flows. I find it to be pretty helpful in understand how and why things do the things they do. This diagram is a little simplified, but it highlights the important things the client and server communicate about when establishing a connection.

![TLS Message Flow Diagram](/assets/img/TLSMessageFlow.drawio.png)

1. The first message that gets sent is the client saying hello to the server to let it know the client exists and wants to connect.
2. The server responds with a hello and offers its certificate. This certificate effectively does 3 things.
   1. The client can verify the identity of the server by checking it with a trusted Certificate Authority.
   2. All communication sent from the client from now on can only be decrypted by the server.
   3. All communication sent from the server can be verified that it is from the server
3. The client uses the encryption and send a symmetric encryption key to the server. That secret is used from then on to encrypt all further communication.

# What is SSL and TLS? Are they different?

The difference between SSL and TLS was a big question I kept asking throughout this adventure. Sometimes I would find tutorials that refer to , or generating "SSL certificates", the library used to generate keys and certificates is called "Open SSL". Other times, I would find references to the protocol for HTTPS being call TLS, when I researched the message flow and how the client and server communicate encryption keys, everything I found referred to TLS.

According to an [Cloudflare article](https://www.cloudflare.com/learning/ssl/what-is-ssl/), it turns out, SSL and TLS are essentially the same thing. SSL was the original name of the protocol when it was owned by Netscape, but in 1999, Internet Engineering Task Force (IETF) changed the name to TLS when they took ownership and added an update to the protocol. My understanding is that it is currently, officially all TLS, but we just use the two names interchangeably.

# HTTPS is weird on an intranet

It might seem a little overkill to go through all this effort encrypting traffic especially on servers that I never plan to open to the outside world. I'll accept that. I am doing most of this for learning, but I also do genuinely have a distrust for technology. Well known and trustworthy companies release products with zero-day vulnerabilities all the time. I don't trust that my router isn't going to allow a bad actor into my network if they ask nicely enough. Also, if I do open up a server to the outside world it's not impossible for someone to use that server to find a way in.

So back to HTTPS, remember that message flow diagram a few sections ago? Remember how the client verifies the certificate with a certificate authority? Well, that's a problem on a local network.

Since we're on a local network, we don't have a certificate authority. Instead, the server claims to be its own authority. In other words, the server just says "trust me, bro". In a lot of cases browsers will just complain about this. Let you know that the browser can't verify the server, but still give you the option to force a connection if you click through the warnings. Some apps, however, don't give you this option and just outright refuse to establish the connection.

At the time of writing this post, I haven't found a solid solution yet. I heard rumor that it's possible to self host a certificate authority. I also understand that you can add the certificate to your operating systems' list of trusted certificate to supress those warnings. I have yet to explore any options deep enough to determine what's the most viable for my use case. I hope to update you in the next blog post.

