---
layout: post
title: "What I learned upgrading my Homelab servers to HTTPS"
tags: Blog, homelab security
---

# Introduction

I use my home network as a playground for learning new technologies and finding unique solutions to minor inconveniences in my life. For example, I couldn't find a thermostat on the market that can control an evaporative cooler and furnace. I was frustrated that each needed its own thermostat, so I designed and built a thermostat myself that could do both. This thermostat is a Raspberry Pi computer that hosts an SSH server, webserver, and Python Fast API in order to work properly. Currently, it's incredibly insecure.

As it stands right now, I can only check on my thermostat and control it when I am physically in my house. I would love to be able to access it from anywhere in the world, but doing so allows anyone pentest it from anywhere in the world. I need to feel a lot more comfortable with the security of my network and these servers before I would feel comfortable doing that.

So in this adventure, I have two goals. First, I would like to actually improve the security of my network and the servers/devices running on it. Second, I would like to generally improve my knowledge of cyber security concepts. So here's a knowledge dump of everything I've learned so far.

# How HTTPS works

A glaringly obvious and seemingly easy to solve issue I have is that my servers communicate via HTTP. This means the messages are sent unencrypted in plaintext. Some of my servers are password protected, and unless I upgrade them to HTTPS, the login information can be seen by anyone who happens to be listening.

HTTPS aims to do two things. The one I'm most interested in is that it encrypts the communication between the client and server, but its second aim is to ensure the server is who it say it is.

## Message flow

*Insert Diagram*

1. Hello | client -> server
2. Certificates and TLS stuff | server -> client
4. Certificate authority verification | client -> CA
3. Symmetric encryption key? | client -> server
4. Request | client -> server
5. Response | server -> client

 * Only encrypted one way?
    * Symmetric key exchange
 * TLS handshake cashing
    * Is a new symmetric key exchanged every time a request is made
 * Certificate validation via a certificate authority

# What is SSL and TLS? Are they different?

This was a big question I kept running into. Sometimes I would find tutorials about "setting up SSL on a server", or generating "SSL certificates", the library used to generate keys and certificates is called "Open SSL". Other times, I would find references to the protocol for HTTPS being call TLS, when I researched the message flow and how the client and server communicate encryption keys, everything I found referred to TLS.

According to an [Cloudflare article](https://www.cloudflare.com/learning/ssl/what-is-ssl/), it turns out, SSL and TLS are essentially the same thing. SSL was the original name of the protocol when it was owned by Netscape, but in 1999, Internet Engineering Task Force (IETF) changed the name to TLS when they took ownership and added an update to the protocol. My understanding is that it is currently, officially all TLS, but we just use the two names interchangeably.

# HTTPS is weird on an intranet

It might seem a little silly to be so worried about encrypting traffic that never leaves a private network. 

Something that became obvious pretty quickly is that HTTPS is a little bit weird when communication is limited to a small network. The more I'm digging into this, the more I am finding limitations in doing so. Most things are designed not to accept certificates that cannot be verified by a trusted Certificate Authority.


